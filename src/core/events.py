import threading
from typing import Dict, List, Callable, Any, Optional
from concurrent.futures import ThreadPoolExecutor
import weakref
from dataclasses import dataclass
from queue import Queue, Empty
import time
from main_logger import logger


@dataclass
class Event:
    """Базовый класс для всех событий"""
    name: str
    data: Any = None
    timestamp: float = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()


class EventBus:
    """
    Потокобезопасная система событий с поддержкой слабых ссылок
    для предотвращения утечек памяти
    """
    
    def __init__(self, max_workers: int = 5):
        self._subscribers: Dict[str, List[weakref.ref]] = {}
        self._lock = threading.RLock()
        self._executor = ThreadPoolExecutor(max_workers=max_workers)
        self._event_queue = Queue()
        self._running = True
        self._processor_thread = threading.Thread(target=self._process_events, daemon=True)
        self._processor_thread.start()
    
    def subscribe(self, event_name: str, callback: Callable, weak: bool = True) -> None:
        """
        Подписаться на событие
        
        Args:
            event_name: Имя события
            callback: Функция обратного вызова
            weak: Использовать слабую ссылку (рекомендуется True)
        """
        with self._lock:
            if event_name not in self._subscribers:
                self._subscribers[event_name] = []
            
            if weak:
                # Используем слабую ссылку для предотвращения циклических ссылок
                weak_ref = weakref.ref(callback, self._create_cleanup_callback(event_name))
                self._subscribers[event_name].append(weak_ref)
            else:
                # Для статических функций можно использовать сильные ссылки
                self._subscribers[event_name].append(callback)
            
            logger.debug(f"Подписка на событие '{event_name}' добавлена")
    
    def unsubscribe(self, event_name: str, callback: Callable) -> None:
        """Отписаться от события"""
        with self._lock:
            if event_name not in self._subscribers:
                return
            
            # Удаляем callback из списка подписчиков
            self._subscribers[event_name] = [
                ref for ref in self._subscribers[event_name]
                if not self._is_same_callback(ref, callback)
            ]
            
            # Удаляем пустые списки
            if not self._subscribers[event_name]:
                del self._subscribers[event_name]
    
    def emit(self, event_name: str, data: Any = None, sync: bool = False) -> None:
        """
        Отправить событие
        
        Args:
            event_name: Имя события
            data: Данные события
            sync: Выполнить синхронно (блокирующий вызов)
        """
        event = Event(name=event_name, data=data)
        
        # Добавить отладку
        with self._lock:
            subscribers_count = len(self._get_active_subscribers(event_name))
            if subscribers_count > 0:
                logger.debug(f"Emitting event '{event_name}' to {subscribers_count} subscribers")
            else:
                logger.warning(f"No subscribers for event '{event_name}'")
        
        if sync:
            self._emit_sync(event)
        else:
            self._event_queue.put(event)
    
    def emit_and_wait(self, event_name: str, data: Any = None, timeout: float = 5.0) -> List[Any]:
        """
        Отправить событие и дождаться результатов от всех подписчиков
        
        Returns:
            Список результатов от подписчиков
        """
        results = []
        result_queue = Queue()
        
        # Создаем специальный wrapper для сбора результатов
        def result_wrapper(callback):
            def wrapper(*args, **kwargs):
                try:
                    result = callback(*args, **kwargs)
                    result_queue.put(result)
                except Exception as e:
                    logger.error(f"Ошибка в обработчике события: {e}")
                    result_queue.put(None)
            return wrapper
        
        with self._lock:
            subscribers = self._get_active_subscribers(event_name)
        
        if not subscribers:
            return results
        
        # Запускаем все обработчики
        for subscriber in subscribers:
            wrapped = result_wrapper(subscriber)
            self._executor.submit(wrapped, Event(name=event_name, data=data))
        
        # Собираем результаты с таймаутом
        start_time = time.time()
        collected = 0
        
        while collected < len(subscribers) and (time.time() - start_time) < timeout:
            try:
                result = result_queue.get(timeout=0.1)
                if result is not None:
                    results.append(result)
                collected += 1
            except Empty:
                continue
        
        return results
    
    def shutdown(self) -> None:
        """Остановить систему событий"""
        self._running = False
        self._event_queue.put(None)  # Сигнал для остановки
        self._processor_thread.join(timeout=5)
        self._executor.shutdown(wait=True)
    
    def _process_events(self) -> None:
        """Обработчик очереди событий (работает в отдельном потоке)"""
        while self._running:
            try:
                event = self._event_queue.get(timeout=0.1)
                if event is None:  # Сигнал остановки
                    break
                
                self._emit_async(event)
            except Empty:
                continue
            except Exception as e:
                logger.error(f"Ошибка при обработке события: {e}", exc_info=True)
    
    def _emit_sync(self, event: Event) -> None:
        """Синхронная отправка события"""
        with self._lock:
            subscribers = self._get_active_subscribers(event.name)
        
        for subscriber in subscribers:
            try:
                subscriber(event)
            except Exception as e:
                logger.error(f"Ошибка при обработке события '{event.name}': {e}", exc_info=True)
    
    def _emit_async(self, event: Event) -> None:
        """Асинхронная отправка события"""
        with self._lock:
            subscribers = self._get_active_subscribers(event.name)
        
        for subscriber in subscribers:
            self._executor.submit(self._safe_call, subscriber, event)
    
    def _safe_call(self, callback: Callable, event: Event) -> None:
        """Безопасный вызов обработчика"""
        try:
            callback(event)
        except Exception as e:
            logger.error(f"Ошибка при обработке события '{event.name}': {e}", exc_info=True)
    
    def _get_active_subscribers(self, event_name: str) -> List[Callable]:
        """Получить список активных подписчиков"""
        if event_name not in self._subscribers:
            return []
        
        active_subscribers = []
        dead_refs = []
        
        for ref in self._subscribers[event_name]:
            if isinstance(ref, weakref.ref):
                callback = ref()
                if callback is not None:
                    active_subscribers.append(callback)
                else:
                    dead_refs.append(ref)
            else:
                # Сильная ссылка
                active_subscribers.append(ref)
        
        # Очистка мертвых ссылок
        if dead_refs:
            for dead_ref in dead_refs:
                self._subscribers[event_name].remove(dead_ref)
        
        return active_subscribers
    
    def _create_cleanup_callback(self, event_name: str):
        """Создать callback для очистки мертвых ссылок"""
        def cleanup(weak_ref):
            with self._lock:
                if event_name in self._subscribers:
                    try:
                        self._subscribers[event_name].remove(weak_ref)
                        if not self._subscribers[event_name]:
                            del self._subscribers[event_name]
                    except ValueError:
                        pass
        return cleanup
    
    def _is_same_callback(self, ref: Any, callback: Callable) -> bool:
        """Проверить, указывает ли ссылка на тот же callback"""
        if isinstance(ref, weakref.ref):
            return ref() is callback
        else:
            return ref is callback


# Глобальный экземпляр для удобства использования
_global_event_bus: Optional[EventBus] = None


def get_event_bus() -> EventBus:
    """Получить глобальный экземпляр EventBus"""
    global _global_event_bus
    if _global_event_bus is None:
        _global_event_bus = EventBus()
    return _global_event_bus


def shutdown_event_bus() -> None:
    """Остановить глобальный EventBus"""
    global _global_event_bus
    if _global_event_bus is not None:
        _global_event_bus.shutdown()
        _global_event_bus = None


# Удобные алиасы для быстрого доступа
def subscribe(event_name: str, callback: Callable, weak: bool = True) -> None:
    """Подписаться на событие через глобальный EventBus"""
    get_event_bus().subscribe(event_name, callback, weak)


def unsubscribe(event_name: str, callback: Callable) -> None:
    """Отписаться от события через глобальный EventBus"""
    get_event_bus().unsubscribe(event_name, callback)


def emit(event_name: str, data: Any = None, sync: bool = False) -> None:
    """Отправить событие через глобальный EventBus"""
    get_event_bus().emit(event_name, data, sync)


def emit_and_wait(event_name: str, data: Any = None, timeout: float = 5.0) -> List[Any]:
    """Отправить событие и дождаться результатов через глобальный EventBus"""
    return get_event_bus().emit_and_wait(event_name, data, timeout)


# Определение имен событий для типобезопасности
class Events:
    """Константы с именами событий"""
    
    # UI события
    SEND_MESSAGE = "send_message"
    CLEAR_CHAT = "clear_chat"
    LOAD_HISTORY = "load_history"
    UPDATE_TOKEN_COUNT = "update_token_count"
    UPDATE_STATUS = "update_status"
    UPDATE_DEBUG_INFO = "update_debug_info"
    
    # Настройки
    SAVE_SETTING = "save_setting"
    GET_SETTING = "get_setting"
    LOAD_SETTINGS = "load_settings"
    
    # Работа с изображениями
    ATTACH_IMAGES = "attach_images"
    STAGE_IMAGE = "stage_image"
    CLEAR_STAGED_IMAGES = "clear_staged_images"
    CAPTURE_SCREEN = "capture_screen"
    GET_CAMERA_FRAMES = "get_camera_frames"
    
    # Голосовые модели
    SELECT_VOICE_MODEL = "select_voice_model"
    INIT_VOICE_MODEL = "init_voice_model"
    CHECK_MODEL_INSTALLED = "check_model_installed"
    CHECK_MODEL_INITIALIZED = "check_model_initialized"
    CHANGE_VOICE_LANGUAGE = "change_voice_language"
    REFRESH_VOICE_MODULES = "refresh_voice_modules"
    
    # Статусы
    GET_CONNECTION_STATUS = "get_connection_status"
    GET_SILERO_STATUS = "get_silero_status"
    GET_MIC_STATUS = "get_mic_status"
    GET_SCREEN_CAPTURE_STATUS = "get_screen_capture_status"
    GET_CAMERA_CAPTURE_STATUS = "get_camera_capture_status"
    
    # Управление потоками
    STOP_SCREEN_CAPTURE = "stop_screen_capture"
    STOP_CAMERA_CAPTURE = "stop_camera_capture"
    DELETE_SOUND_FILES = "delete_sound_files"
    STOP_SERVER = "stop_server"
    
    # История чата
    GET_CHAT_HISTORY = "get_chat_history"
    LOAD_MORE_HISTORY = "load_more_history"
    
    # Mita статус
    SHOW_MITA_THINKING = "show_mita_thinking"
    SHOW_MITA_ERROR = "show_mita_error"
    HIDE_MITA_STATUS = "hide_mita_status"
    PULSE_MITA_ERROR = "pulse_mita_error"
    
    # Telegram
    REQUEST_TG_CODE = "request_tg_code"
    REQUEST_TG_PASSWORD = "request_tg_password"
    
    # G4F
    SCHEDULE_G4F_UPDATE = "schedule_g4f_update"
    
    # Разное
    CHECK_TEXT_TO_TALK = "check_text_to_talk"
    GET_CHARACTER_NAME = "get_character_name"
    GET_CURRENT_CONTEXT_TOKENS = "get_current_context_tokens"
    CALCULATE_COST = "calculate_cost"

        # Персонажи
    GET_ALL_CHARACTERS = "get_all_characters"
    GET_CURRENT_CHARACTER = "get_current_character"
    SET_CHARACTER_TO_CHANGE = "set_character_to_change"
    CHECK_CHANGE_CHARACTER = "check_change_character"
    GET_CHARACTER = "get_character"
    RELOAD_CHARACTER_DATA = "reload_character_data"
    RELOAD_CHARACTER_PROMPTS = "reload_character_prompts"
    CLEAR_CHARACTER_HISTORY = "clear_character_history"
    CLEAR_ALL_HISTORIES = "clear_all_histories"
    
    # Микрофон и речь
    SET_MICROPHONE = "set_microphone"
    START_SPEECH_RECOGNITION = "start_speech_recognition"
    STOP_SPEECH_RECOGNITION = "stop_speech_recognition"
    UPDATE_SPEECH_SETTINGS = "update_speech_settings"
    
    # Асинхронные операции
    GET_EVENT_LOOP = "get_event_loop"
    RELOAD_PROMPTS_ASYNC = "reload_prompts_async"
    
    # Загрузка
    SHOW_LOADING_POPUP = "show_loading_popup"
    CLOSE_LOADING_POPUP = "close_loading_popup"

    # Отладка
    GET_DEBUG_INFO = "get_debug_info"

    # От chat_handler.py
    SET_TTS_DATA = "set_tts_data"
    GET_USER_INPUT = "get_user_input"

    # События chat_handler.py
    ON_STARTED_RESPONSE_GENERATION = "on_started_response_generation"
    ON_SUCCESSFUL_RESPONSE = "on_successful_response"
    ON_FAILED_RESPONSE = "on_failed_response"
    ON_FAILED_RESPONSE_ATTEMPT = "on_failed_attempt_for_response"

    # от server.py
    UPDATE_GAME_CONNECTION = "update_game_connection"
    SET_CHARACTER_TO_CHANGE = "set_character_to_change"
    SET_GAME_DATA = "set_game_data"
    SET_DIALOG_ACTIVE = "set_dialog_active"
    ADD_TEMPORARY_SYSTEM_INFO = "add_temporary_system_info"
    SET_ID_SOUND = "set_id_sound"
    UPDATE_CHAT = "update_chat"
    GET_SERVER_DATA = "get_server_data"
    GET_SETTINGS = "get_settings"
    RESET_SERVER_DATA = "reset_server_data"
    CLEAR_USER_INPUT = "clear_user_input"
    SET_WAITING_ANSWER = "set_waiting_answer"
    GENERATE_RESPONSE = "generate_response"
    SET_CONNECTED_TO_GAME = "set_connected_to_game"

    # От telegram_handler.py
    SET_SOUND_FILE_DATA = "set_sound_file_data"
    GET_TG_AUTH_DATA = "get_tg_auth_data"
    SET_SILERO_CONNECTED = "set_silero_connected"

    # GUI события
    
    # От main_controller.py
    CLEAR_USER_INPUT_UI = "clear_user_input_ui"
    PREPARE_STREAM_UI = "prepare_stream_ui"
    APPEND_STREAM_CHUNK_UI = "append_stream_chunk_ui"
    FINISH_STREAM_UI = "finish_stream_ui"
    CHECK_AND_INSTALL_FFMPEG = "check_and_install_ffmpeg"
    UPDATE_STATUS_COLORS = "update_status_colors"
    UPDATE_CHAT_UI = "update_chat_ui"
    PREPARE_STREAM_UI = "prepare_stream_ui"
    APPEND_STREAM_CHUNK_UI = "append_stream_chunk_ui"
    FINISH_STREAM_UI = "finish_stream_ui"
    CHECK_AND_INSTALL_FFMPEG = "check_and_install_ffmpeg"

    # От speech_controller.py
    INSERT_TEXT_TO_INPUT = "insert_text_to_input"
    CHECK_USER_ENTRY_EXISTS = "check_user_entry_exists"

    # От settings_controller.py
    SWITCH_VOICEOVER_SETTINGS = "switch_voiceover_settings"
    SHOW_INFO_MESSAGE = "show_info_message" 
    UPDATE_CHAT_FONT_SIZE = "update_chat_font_size"
    RELOAD_CHAT_HISTORY = "reload_chat_history"
    UPDATE_TOKEN_COUNT_UI = "update_token_count_ui"
    GET_GUI_WINDOW_ID = "get_gui_window_id"

    # От audio_controller.py
    CHECK_TRITON_DEPENDENCIES = "check_triton_dependencies"
    UPDATE_MODEL_LOADING_STATUS = "update_model_loading_status"
    FINISH_MODEL_LOADING = "finish_model_loading"
    SHOW_ERROR_MESSAGE = "show_error_message"
    CANCEL_MODEL_LOADING = "cancel_model_loading"

    # От telegram_controller.py
    PROMPT_FOR_TG_CODE = "prompt_for_tg_code"
    PROMPT_FOR_TG_PASSWORD = "prompt_for_tg_password"
    TELEGRAM_SEND_VOICE_REQUEST = "telegram_send_voice_request"

    # От capture_controller.py
    START_SCREEN_CAPTURE = "start_screen_capture"
    STOP_SCREEN_CAPTURE = "stop_screen_capture"
    START_CAMERA_CAPTURE = "start_camera_capture"
    STOP_CAMERA_CAPTURE = "stop_camera_capture"
    START_IMAGE_REQUEST_TIMER = "start_image_request_timer"
    STOP_IMAGE_REQUEST_TIMER = "stop_image_request_timer"
    UPDATE_SCREEN_CAPTURE_EXCLUSION = "update_screen_capture_exclusion"
    CAPTURE_SETTINGS_LOADED = "capture_settings_loaded"
    SEND_PERIODIC_IMAGE_REQUEST = "send_periodic_image_request"

    # От chat_controller.py
    GET_LLM_PROCESSING_STATUS = "get_llm_processing_status"

    # От server_controller.py
    GET_CHAT_SERVER = "get_chat_server"

    GET_INSTANT_SEND_STATUS = "get_instant_send_status"
    SET_INSTANT_SEND_STATUS = "set_instant_send_status"

